# src/scoring.py

from __future__ import annotations

from typing import Optional
import numpy as np
import pandas as pd


def _zscore(s: pd.Series) -> pd.Series:
    s = pd.to_numeric(s, errors="coerce").astype(float)
    mu = s.mean()
    sd = s.std(ddof=0)
    if sd == 0 or np.isnan(sd):
        return pd.Series(0.0, index=s.index)
    return (s - mu) / sd


def build_business_risk_table(
    burst_df: pd.DataFrame,
    skew_df: pd.DataFrame,
    overlap_df: pd.DataFrame,
    weights: Optional[dict] = None,
) -> pd.DataFrame:
    """
    Merge business-level signals and compute a single risk score.

    Expected inputs:
      burst_df: columns [business_id, burst_score, ...]
      skew_df:  columns [business_id, rating_skew, pct_5star, n_reviews, ...]
      overlap_df: columns [business_id, overlap_score or overlap_ratio, ...]
    """

    if weights is None:
        weights = {
            "burst_score": 0.45,
            "rating_skew": 0.35,
            "overlap_score": 0.20,  # will also accept overlap_ratio
        }

    # Normalize column naming for overlap
    overlap = overlap_df.copy()
    if "overlap_score" not in overlap.columns:
        if "overlap_ratio" in overlap.columns:
            overlap = overlap.rename(columns={"overlap_ratio": "overlap_score"})
        elif "reviewer_overlap" in overlap.columns:
            overlap = overlap.rename(columns={"reviewer_overlap": "overlap_score"})

    # Keep only what we need + avoid column collisions
    b = burst_df[["business_id", "burst_score"]].copy()
    s = skew_df[["business_id", "rating_skew"]].copy()
    o = overlap[["business_id", "overlap_score"]].copy()

    risk = b.merge(s, on="business_id", how="outer").merge(o, on="business_id", how="outer")
    risk = risk.fillna(0)

    # Standardize (z-score) so signals are comparable
    risk["z_burst"] = _zscore(risk["burst_score"])
    risk["z_skew"] = _zscore(risk["rating_skew"])
    risk["z_overlap"] = _zscore(risk["overlap_score"])

    # Weighted risk score
    risk["risk_score"] = (
        weights.get("burst_score", 0) * risk["z_burst"]
        + weights.get("rating_skew", 0) * risk["z_skew"]
        + weights.get("overlap_score", 0) * risk["z_overlap"]
    )

    # Nice-to-have: percentile rank (0..1)
    risk["risk_percentile"] = risk["risk_score"].rank(pct=True)

    return risk.sort_values("risk_score", ascending=False).reset_index(drop=True)
